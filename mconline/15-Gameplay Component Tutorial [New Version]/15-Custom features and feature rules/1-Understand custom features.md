--- 
front: https://nie.res.netease.com/r/pic/20211104/69055361-2e7a-452f-8b1a-f23e1262a03a.jpg 
hard: Advanced 
time: 25 minutes 
--- 

# Understanding Custom Features 

Features (also known as terrain objects) are structures composed of one or more blocks that embellish the terrain in the world. The trees, flowers, ores, ruins, villages, lakes, crystal caves and other terrains we see in the original world are all generated by features. Features play the role of various microscopic details of the world seen by players. With the generation of features, the local unchanging terrain structure generated by noise and biomes in the world has more detailed changes. In this section, let's learn how to customize a feature. 

## Understanding the structure of feature files 

In Chapter 6, we learned how to customize a feature through the editor, but we also learned that the current editor only supports configuring one **Structure Feature** (**Structure Feature**, also translated as **Structure Feature**). This structure feature is actually a feature type exclusive to the Chinese version. In addition to this feature type exclusive to the Chinese version, we also have many feature types provided by the international version that can be used for customization. In order to customize more types of features, we need to manually edit the JSON file to change the type and parameters of the feature. Before that, let's take a look at the JSON content of the Chinese version of the structure feature created earlier: 

```json 
{ 
"format_version": "1.14.0", 
"netease:structure_feature": { 
"description": { 
"identifier": "tutorial_demo:demo_feature" 
}, 
"places_structure": "tutorial_demo:pondwaterland" 
} 
} 
``` 

We can see that our structure template feature is stored in the `netease_features` folder of the behavior pack. The generation of structures in this folder does not require experimental gameplay to be enabled, and all international version feature types are supported at the same time, so all our subsequent features can be placed in this folder. 

`netease:structure_feature` is the **Schema Identifier** of the feature. As the name suggests, the schema identifier is an identifier used to determine the **Schema** of the JSON file. As we have learned before, the pattern of the JSON file determines the file structure used by the JSON file. For example, the pattern of `netease:structure_feature` determines that there are two fields under it, `description` and `places_structure`, neither of which can be missing. For another example, the pattern of `minecraft:client_entity` determines that there can only be one `description` field under it, but `description` can have many fields of various functions; and the `minecraft:entity` pattern determines that there can be one `description` and one `components`, and `components` can have many behavior pack components. The **Format Version** is the modification of the structure and properties of each field according to the changes in the game version after the pattern identifier is determined, which includes the modification of field names, the modification of the required and optional nature of fields, and the addition and deletion of fields. For example, the `description` of the `1.8.0` format version of `minecraft:client_entity` contains the `animation_controllers` array, which is used to define animation controllers, while the `1.10.0` format version deletes this field and defines animation controllers in the same place as animations, the `animations` object. 

In fact, if you have looked at the original feature JSON file, you should have noticed that the pattern identifier of features is not unified like the `minecraft:block` of blocks, `minecraft:item` of items, and `minecraft:client_entity` and `minecraft:entity` of the client and server of entities. The pattern identifier of features will be different for different types of features. For example, the pattern identifier of the structure feature in the Chinese version uses `netease:structure_feature`, while the various feature types provided by the international version use other pattern identifiers. Such as `minecraft:ore_feature`, `minecraft:single_block_feature`, etc. That is to say, unlike items, blocks, and entities, which define descriptions and components under the same pattern identifier, features use different pattern identifiers and different pattern structures according to different feature types. So for each type of feature, we need to learn its file structure separately. 

Because the pattern identifiers are not consistent, the format version should also change accordingly. The format version of the Chinese version of the structure feature `netease:structure_feature` is `1.14.0`. In addition, the format versions of various types of features in the international version are different, but most of them are `1.13.0`, and a few pattern identifiers use the format versions of `1.16.0` and `1.16.100`. 

Next, we will learn some basic types of features by pattern identifier. 

## Custom ore features 

The pattern identifier of the ore feature is `minecraft:ore_feature`, and the conventional format version is `1.13.0`, and `1.16.0` can also be used. The ore feature is designed to simulate the ore deposit structure of ore generation. In fact, any block can be used as an input block for the ore feature, not necessarily an ore. Let's take a look at an example: 

```json 
{ 
"format_version": "1.13.0", 
"minecraft:ore_feature": { 
"description": { 
"identifier": "example:malachite_ore_feature" 
}, 
"count": 12, 
"replace_rules": [ 
{

"places_block": "example:malachite_ore", 
"may_replace": [ 
"minecraft:stone" 
] 
}, 
{ 
"places_block": "example:granite_malachite_ore", 
"may_replace": [ 
"minecraft:granite" 
] 
}, 
{ 
"places_block": "example:andesite_malachite_ore", 
"may_replace": [ 
"minecraft:andesite" 
] 
} 
] 
} 
} 
``` 

`count` is the number of times the ore feature attempts to replace, and `replace_rules` is the replacement rules. The principle of ore features is to replace a specified block or blocks with a specific block, usually an ore block. For example, in the example, the feature tries to replace `minecraft:stone` with `example:malachite_ore`, `minecraft:granite` with `example:granite_malachite_ore`, and `minecraft:andesite` with `example:andesite_malachite_ore`. If the `replace_rules` field is not filled in, it means that the block can replace any other block. 

## Custom Single Block Feature 

The mode identifier of the single block feature is `minecraft:single_block_feature`, and the conventional format version is `1.13.0`, and `1.16.0` can also be used. The single block feature is intended to place a single block, such as small blocks such as flowers and plants. During placement, we can set the replaceable blocks like the ore feature, or we can set the attachable blocks, that is, we can make this block only be attached to certain faces of a certain block or blocks. 

```json
{
  "format_version": "1.13.0",
  "minecraft:single_block_feature": {
    "description": {
      "identifier": "minecraft:cocoa_age_0_feature"
    },
    "places_block": {
      "name": "minecraft:cocoa",
      "states": {
        "age": 0
      }
    },
    "enforce_survivability_rules": false,
    "enforce_placement_rules": false,
    "may_attach_to": {
      "min_sides_must_attach": 1,
      "sides": {
        "name": "minecraft:log",
        "states": {
          "old_log_type": "jungle"
        }

} 
} 
} 
} 
``` 

`places_block` is the block to be placed, and a **Block Reference** format is used here. Not only here, but all positions that can be filled with a block identifier can also be filled with a block reference object like this `{"name": "<namespace:identifier>", "states": {"<state1>": <someValue>, "<state2>": <someValue> ... }}`. When the block state `states` field is not specified, writing a block identifier alone is equivalent to writing a block reference object. The advantage of block references is that they can be used to specify a specific block state. Here, it is used to directly generate a block of a specific state in the feature. The `may_replace` field is used to specify the block that can be replaced. It is an array like the `may_replace` in the ore feature above. The `may_replace` field is not used in our example. This field is on the same level as `places_block`. `may_attach_to` is also on the same level as `places_block`, and is used to specify which faces of which blocks can be attached. `enforce_survivability_rules` and `enforce_placement_rules` are used to tell the engine whether to enable the survivability and placement checks of blocks respectively. Blocks can define placement and survivability by setting the `minecraft:placement_filter` block component in the behavior pack. However, it is worth noting that this block component is a block component after `1.16.100`. If you need to use it, please pay attention to the format version. 

## Custom scattering feature 

The pattern identifier of the scattering feature is `minecraft:scatter_feature`, and the conventional format version is `1.13.0`. This feature is designed to scatter a feature one or more times, that is, scatter one or more specified features around it relative to the starting point of the feature.

```json
{
  "format_version": "1.13.0",
  "minecraft:scatter_feature": {
    "description": {
      "identifier": "minecraft:grass_double_plant_patch_feature"
    },
    "iterations": 64,
    "scatter_chance": {
      "numerator": 1,
      "denominator": 80
    },
    "coordinate_eval_order": "zyx",
    "x": {
      "extent": [ -8, 8 ],
      "distribution": "gaussian"
    },
    "z": 10,
    "y": "math.cos(math.random(0, 10))",
    "project_input_to_floor": false,
    "places_feature": "minecraft:grass_double_plant_feature" } 
} 
``` 

This is an example of a patch feature of a modified double-layer tall grass. `iterations` represents the number of iterations, that is, the number of scattering. `scatter_chance` represents the possibility of scattering. This field can be a number representing a percentage, such as 50 represents the probability of "50%"; or an object can be used, which represents a fraction, where `numerator` is the numerator and `denominator` is the denominator. We call this object representing a fraction a **Chance Information**. If `scatter_chance` passes, it will perform `iterations` number of scattering iterations. If it fails, no iteration will be performed. `coordinate_eval_order` is the coordinate string calculation order, which represents the calculation order of the values in the following three axes XYZ. Generally speaking, the calculation order of the three axes does not affect the final result, but if variables are used to store information when using Molang expressions to perform operations on the three axes, the calculation order will cause differences in the results. The three fields `x`, `y`, and `z` can use a value, a Molang expression, or an object to specify a distribution function. In the above example, Gaussian distribution is used on the X axis to calculate the destination coordinates of the scattered plants. 

## Custom aggregation features 

The pattern identifier of the aggregation feature is `minecraft:aggregate_feature`, and the custom format version is `1.13.0`. The aggregation feature is designed to generate one or more features in one place, that is, to aggregate them together. 

```json 
{ 
"format_version": "1.13.0", 
"minecraft:aggregate_feature": { 
"description": { 
"identifier": "minecraft:bamboo_then_podzol_feature" 
},

"early_out": "first_failure", 
"features": [ 
"minecraft:bamboo_feature", 
"minecraft:optional_podzol_feature" 
] 
} 
} 
``` 

The `features` array is the list of features we want to aggregate. The `early_out` field can be used to specify whether the aggregation will exit early for any reason. For example, `first_failure` means that if a feature fails to be placed during the aggregation process, the entire aggregation will be terminated. 

## Custom sequence features 

The pattern identifier of the sequence feature is `minecraft:sequence_feature`, and the idiomatic format version is `1.13.0`. Sequence features are very similar to aggregate features. They are both features used to place multiple other features. However, the starting point of the sequence feature is not fixed at a certain position, but the starting point of the next feature in the placement list will use the end point of the previous feature. 

```json 
{ 
"format_version": "1.13.0", 
"minecraft:sequence_feature": { 
"description": { 
"identifier": "minecraft:jungle_tree_with_cocoa_feature" 
}, 
"features": [ 
"minecraft:jungle_tree_feature", 
"minecraft:optional_jungle_tree_cocoa_feature" 
] 
} 
} 
``` 

The `features` array is a list of features we want to place. 

## Custom Search Features 

The pattern identifier for search features is `minecraft:search_feature`, and the format version used is `1.13.0`. Search features are designed to search for a feature in a specific order within their bounding box along an axis, and once a suitable location is found, a feature is placed. By default, search features terminate after a successful placement, but the number of successful placements can be changed. 

```json
{
  "format_version": "1.13.0",
  "minecraft:search_feature": {
    "description": {
      "identifier": "minecraft:beehive_search_feature"
    },
    "places_feature": "minecraft:select_beehive_feature",
    "search_volume": {
      "min": [ 0, 0, 0 ],
      "max": [0, 6, 0]
    },
    "search_axis": "+y",
    "required_successes": 1

} 
} 
``` 

`required_successes` is the number of successes required before stopping the search. The feature will stop searching and placing after the number of successes is met or the bounding box volume of the axis specified in `search_volume` is exhausted. `search_axis` represents the search order, where `+y` represents the positive Y axis, and we can naturally infer the meaning of `-y`, `±x`, and `±z`. For `+y`, the search order is from the layer with low Y value to the layer with high Y value, and then in each Y layer, from the bottom left corner to the top right corner from the perspective of the search direction. Once a location that meets the placement requirements is found during the search process, the feature can be placed and the search count is increased by 1. 

## Custom weighted random features 

The pattern identifier of weighted random features is `minecraft:weighted_random_feature`, and the usual format version is `1.13.0`. Weighted random features are designed to randomly select a feature from many features by weight for placement. 

```json
{
  "format_version": "1.13.0",
  "minecraft:weighted_random_feature": {
    "description": {
      "identifier": "minecraft:random_meadow_flower_feature"
    },
    "features": [
      ["minecraft:yellow_flower_feature", 5],
      ["minecraft:cornflower_feature", 5],
      ["minecraft:tall_grass_feature", 1]
    ] } 
} 
``` 

A weighted random feature can only be placed once. In the above example, in one placement, `minecraft:yellow_flower_feature` has a probability of $\frac{5}{11}$ to be selected, `minecraft:cornflower_feature` also has a probability of $\frac{5}{11}$ to be selected, and `minecraft:tall_grass_feature` has a probability of $\frac{1}{11}$ to be selected. 

## Custom tree feature 

The tree feature is one of the most complex features. Its pattern identifier is `minecraft:tree_feature` and the idiomatic format version is `1.13.0`. With the tree feature, we can make some tree-like block structures. Let's look at a vanilla birch tree feature: 

```json 
{ 
"format_version": "1.13.0", 
"minecraft:tree_feature": { 
"description": { 
"identifier": "minecraft:birch_tree_feature" 
}, 
"trunk": { 
"trunk_height": { 
"range_min": 5, 
"range_max": 8 
}, 
"trunk_block": { 
"name": "minecraft:log", 
"states": { 
"old_log_type": "birch" 
} 
}

    },
    "canopy": {
      "canopy_offset": {
        "min": -3,
        "max": 0
      },
      "variation_chance": [
        {
          "numerator": 1,
          "denominator": 2
        },
        {
          "numerator": 1,
          "denominator": 2
        },
        {
          "numerator": 1,
          "denominator": 2
        },
        {
          "numerator": 1,
          "denominator": 1
        }
      ],
      "leaf_block": {
        "name": "minecraft:leaves",
        "states": {
          "old_leaf_type": "birch"
        }
      }
    },
    "base_block": [
      "minecraft:dirt",
      {
        "name": "minecraft:dirt",
        "states": {
          "dirt_type": "coarse"
        }
      }
    ],
    "may_grow_on": [
      "minecraft:dirt",
      "minecraft:grass",
      "minecraft:podzol",
      "minecraft:dirt_with_roots",
      "minecraft:moss_block",
      // Block aliases sure would be sweet
      {
        "name": "minecraft:dirt",
        "states": {

          "dirt_type": "coarse"
        }
      },
      {
        "name": "minecraft:farmland",
        "states": {
          "moisturized_amount": 0
        }
      },
      {
        "name": "minecraft:farmland",
        "states": {
          "moisturized_amount": 1
        }
      },
      {
        "name": "minecraft:farmland",
        "states": {
          "moisturized_amount": 2
        }
      },
      {
        "name": "minecraft:farmland",
        "states": {
          "moisturized_amount": 3
        }
      },
      {
        "name": "minecraft:farmland",
        "states": {
          "moisturized_amount": 4
        }      },
      {
        "name": "minecraft:farmland",
        "states": {
          "moisturized_amount": 5
        }
      },
      {
        "name": "minecraft:farmland",
        "states": {
          "moisturized_amount": 6
        }
      },
      {
        "name": "minecraft:farmland",
        "states": {
          "moisturized_amount": 7
        }

      }
    ],
    "may_replace": [
      "minecraft:air",
      {
        "name": "minecraft:leaves",
        "states": {
          "old_leaf_type": "oak"
        }
      },
      {
        "name": "minecraft:leaves",
        "states": {
          "old_leaf_type": "spruce"
        }
      },
      {
        "name": "minecraft:leaves",
        "states": {
          "old_leaf_type": "birch"
        }
      },
      {
        "name": "minecraft:leaves",
        "states": {
          "old_leaf_type": "jungle"
        }
      },
      {
        "name": "minecraft:leaves2",
        "states": {
          "new_leaf_type": "acacia"
        }
      },
      {
        "name": "minecraft:leaves2",
        "states": {
          "new_leaf_type": "dark_oak"
        }
      }
    ],
    "may_grow_through": [
      "minecraft:dirt",
      "minecraft:grass",
      {
        "name": "minecraft:dirt",
        "states": {
          "dirt_type": "coarse"
        }
      }

] 
} 
} 
``` 

For the tree feature, we first need to specify a **trunk** shape, and here we use the `trunk` field. In fact, we have a variety of trunk shapes to choose from, such as `trunk`, `fallen_trunk`, `acacia_trunk`, `mega_trunk`, `fancy_trunk`, etc. We can only choose one of the many trunk shape fields. The subfields in different trunk shape objects are also different, and generally there will be `trunk_height` and `trunk_block`, which represent the height of the trunk and the block used by the trunk, respectively. We can see that `trunk_block` uses a block reference object. From the previous learning, we can know that any place where a block reference object can be used can directly use a block identifier string. Therefore, here `trunk_block` can actually be followed by a block identifier. Next is the `canopy` field at the same level as `trunk`, which represents the properties of the **canopy**. `canopy_offset` represents the offset of the canopy, while `variation_chance` represents the possibility of variation of the canopy. The leaf block used by the canopy is specified by `leaf_block`. Like the trunk, the canopy can also have other types, such as the random spread canopy `random_spread_canopy` that is often used with the acacia trunk. After that, `base_block` is used to specify the **base** block of the tree feature, that is, the block where the tree should be after it is generated. If the tree is not under this block before it is generated, the tree will replace it with this block. `may_grow_on` is used to specify which blocks the tree can be generated on. We can see that although there is no grass block in the base block of the birch tree, the birch tree can be generated on the grass block, which can be reflected in the fact that we can plant birch saplings on the grass block. `may_replace` is the block that can be used to replace the tree feature during its growth. These blocks will be randomly replaced with part of the tree and become the blocks that make up the tree. Finally, `may_grow_through` is the block that the tree can grow through. In other words, the tree can replace these blocks with its own blocks. 

Tree features are very complex but also very efficient. Developers can fully learn how to write tree features by reading the original JSON files of various features. Of course, other types of features can also be learned by reading the code. This learning method is both efficient and accurate, and is undoubtedly a very effective learning method.