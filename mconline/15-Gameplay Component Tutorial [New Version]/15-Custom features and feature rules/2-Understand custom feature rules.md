--- 
front: https://nie.res.netease.com/r/pic/20211104/69055361-2e7a-452f-8b1a-f23e1262a03a.jpg 
hard: Advanced 
time: 15 minutes 
--- 
# Understanding Custom Feature Rules 

In Chapter 6, we have already had a preliminary understanding of how to create a **Feature Rule** (**Feature Rule**, also translated as **Ground Object Rule**) through the editor. In this section, we will learn more about feature rules from the JSON level. 

## Understanding feature rule files 

Let's first look at the code for the feature rule we created using the editor: 

```json 
{ 
"format_version": "1.14.0", 
"minecraft:feature_rules": { 
"description": { 
"identifier": "tutorial_demo:demo_feature_rules", 
"places_feature": "tutorial_demo:demo_feature" 
}, 
"conditions": { 
"placement_pass": "surface_pass" 
}, 
"distribution": { 
"coordinate_eval_order": "xzy", 
"iterations": 1, 
"scatter_chance": 10, 
"x": { 
"distribution": "uniform", 
"extent": [ 
0, 
16 
] 
}, 
"y": "query.get_height_at(variable.originx,variable.originz)-3", 
"z": { 
"distribution": "uniform", 
"extent": [ 
0, 
16 
] 
} 
} 
} 
} 
``` 

We can see that feature rules can be placed in the `netease_feature_rules` folder, and the pattern identifier used is `minecraft:feature_rules`, and here we use the `1.14.0` format version. In fact, we can also use the `1.13.0` and `1.16.0` format versions.


There are three fields under the pattern identifier, namely, `description`, `conditions`, and `distribution`, which are the description, conditions, and distribution of the feature rule. Among them, we can see that the content in the distribution object `distribution` is very familiar. Yes, the format here is exactly the same as that of the scattered planting feature. In fact, each defined feature rule will execute a logic similar to the scattered planting feature **chunk by chunk** at different stages of the game's biome generation. Simply put, on each chunk, the feature rule will randomly select a point and then use this point as the starting point to do a scattered planting. Therefore, we can define a set of fields in the `distribution` object with the same format as the scattered planting feature. The only difference is that the `places_feature` field in the scattered planting feature has been moved to the description object `description` here. 

The condition object `conditions` is used to define the conditions for the feature rule to place the feature, and `placement_pass` is the definition of the feature **Placement Pass** that we have previously encountered in Chapter 6. Here we use `surface_pass` to represent the placement of the surface stage in the terrain generated by the generator. 

In our example, the string calculation order of the coordinates of the three axes is `xzy`. At the same time, we can see that the Molang query function is used in the `y` field to obtain the world height at the starting point of the X and Z axes. If the Y axis is calculated before the X and Z axes, we cannot get the starting point coordinates of the X and Z axes through the variables. Then our current logic will fail, which is why we adjusted the string calculation order to `xzy`. 

Let's look at an example of a vanilla feature rule: 

```json 
{ 
"format_version": "1.13.0", 
"minecraft:feature_rules": { 
"description": { 
"identifier": "minecraft:bamboo_jungle_after_surface_bamboo_feature", 
"places_feature": "minecraft:bamboo_then_podzol_feature" 
}, 
"conditions": { 
"placement_pass": "after_surface_pass", 
"minecraft:biome_filter": [ 
{ 
"test": "has_biome_tag", 
"operator": "==", 
"value": "bamboo" 
}, 
{ 
"test": "has_biome_tag", 
"operator": "==", 
"value": "jungle" 
} 
] 
}, 
"distribution": { 
"iterations": "math.clamp(math.trunc(math.ceil((query.noise(math.trunc(variable.originx / 80), math.trunc(variable.originz / 80)) + 0.3) * 160)), 15, 160)", 
"x": { 
"distribution": "uniform", 
"extent": [ 0, 16 ] 
}, 
"y": "query.heightmap(variable.worldx, variable.worldz)", 
"z": { 
"distribution": "uniform", 
"extent": [ 0, 16 ] 
} 
} 
} 
} 
``` 

Here we can see that there is an additional `minecraft:biome_filter` condition under the `conditions` field. This condition is used to filter biomes. Through the linear arrangement or logical combination of one or more filters, we can make the feature rules place features only under specific biomes, which realizes rule-driven feature placement. The features placed in this way are what we previously called **Automatic Feature** (Automatic Feature**), that is, **Implicit Feature** (Implicit Feature**). 


So, from a macro point of view, we have two ways to place features, one is implicit features that are automatically placed by conditional control through feature rules, and the other is explicit features that are forced to be placed through the definition of biomes. 

So far, we have basically learned how to write features and feature rules. In the next few sections, we will work together through various demonstrations to implement the definition and generation of various features.